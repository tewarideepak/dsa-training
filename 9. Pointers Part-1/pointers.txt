📌 Pointers in C++ — Notes

✅ Definition

    A pointer is a variable that stores the memory address of another variable.

    It "points to" the location in memory where data is stored.

🧠 Basic Syntax

int a = 10;
int* ptr = &a; // ptr stores the address of variable a

    * declares a pointer.

    & is the address-of operator, gives the address of a variable.

🔍 Key Concepts

| Concept          | Symbol    | Description                                          |
| ---------------- | --------- | ---------------------------------------------------- |
| Address-of       | `&`       | Gets the address of a variable                       |
| Dereference      | `*`       | Accesses the value at the address the pointer stores |
| Null Pointer     | `nullptr` | Special pointer that points to nothing               |
| Dangling Pointer |           | Points to memory that is freed or out of scope       |
| Wild Pointer     |           | Uninitialized pointer                                |

💡 Pointer Declaration

int* p;    // pointer to int
char* c;   // pointer to char
float* f;  // pointer to float

🎯 Example

#include <iostream>
using namespace std;

int main() {
    int x = 5;
    int* ptr = &x;

    cout << "Value of x: " << x << endl;               // 5
    cout << "Address of x: " << &x << endl;            // e.g., 0x61ff08
    cout << "Value stored in ptr: " << ptr << endl;    // same as &x
    cout << "Value pointed by ptr: " << *ptr << endl;  // 5
}

🧮 Pointer Arithmetic

    Only allowed with pointers to elements of arrays.

int arr[] = {10, 20, 30};
int* p = arr;

cout << *(p + 1); // 20

| Operation | Meaning                    |
| --------- | -------------------------- |
| `p++`     | Move to next element       |
| `p--`     | Move to previous element   |
| `p + n`   | Move `n` elements forward  |
| `p - n`   | Move `n` elements backward |


Array name is a constant pointer.

int arr[] = {1, 2, 3};
int* p = arr;

cout << *p;     // 1
cout << *(p+1); // 2

🧱 Pointer to Pointer

    A pointer that stores the address of another pointer.

int x = 5;
int* p = &x;
int** pp = &p;

cout << **pp; // 5

🛠️ Pointers with Functions

    Call by reference using pointers:

void modify(int* ptr) {
    *ptr = 20;
}

int main() {
    int x = 10;
    modify(&x);
    cout << x; // 20
}

🧰 Dynamic Memory with Pointers

int* p = new int;   // dynamically allocated int
*p = 10;

delete p;           // deallocate memory
p = nullptr;

🧼 Best Practices

    Always initialize pointers:

    int* p = nullptr;

    After delete, set pointer to nullptr to avoid dangling pointers.

    Avoid pointer arithmetic unless necessary.

    Use smart pointers (std::unique_ptr, std::shared_ptr) in modern C++.

⚠️ Common Errors

| Mistake                     | Result                   |
| --------------------------- | ------------------------ |
| Dereferencing null pointer  | Runtime crash (segfault) |
| Forgetting `delete`         | Memory leak              |
| Using uninitialized pointer | Undefined behavior       |
| Using freed memory          | Dangling pointer bug     |

📌 1. Definition

    Pointer: A variable that stores the memory address of another variable.

    Array: A collection of contiguous memory locations of the same data type.

int x = 10;
int* ptr = &x;     // pointer to int
int arr[5] = {1, 2, 3, 4, 5};  // array of ints

📌 2. Memory Allocation

    Array: Allocates a fixed-size block of memory at compile time.

    Pointer: Can point to dynamically or statically allocated memory.

int arr[3];              // fixed at compile time
int* ptr = new int[3];   // allocated at runtime

📌 3. Syntax and Access

    Both use [] for element access, but pointers require memory to be allocated beforehand.

int arr[3] = {10, 20, 30};
int* ptr = arr;

std::cout << arr[1];   // 20
std::cout << ptr[1];   // 20 (pointer arithmetic)

📌 4. Size

    sizeof(array) gives total memory: n × sizeof(type)

    sizeof(pointer) gives size of the pointer itself (usually 4 or 8 bytes)

int arr[5];
int* ptr = arr;

sizeof(arr); // 20 (5 × 4 bytes if int = 4B)
sizeof(ptr); // 8 (on 64-bit system)

📌 5. Modifiability

    Array names are not modifiable (they decay to pointer but can't be reassigned).

    Pointers can be reassigned to point elsewhere.

int a[5], b[5];
int* p = a;
p = b;       // ✅ OK

a = b;       // ❌ Error: array name is not assignable

📌 6. Pointer Arithmetic

    Pointers support arithmetic (+, -) to navigate memory.

    Arrays don’t support pointer arithmetic directly.

int arr[3] = {1, 2, 3};
int* p = arr;

std::cout << *(p + 1);  // 2

📌 7. Function Arguments

    Arrays decay to pointers when passed to functions.

    You usually receive an int* when you pass an int[].

void func(int* ptr) {
  std::cout << ptr[0];
}

int arr[3] = {10, 20, 30};
func(arr);  // ✅ treated as pointer

📌 8. Nullability

    Pointers can be nullptr or NULL.

    Arrays cannot be null — they must point to valid memory.

int* p = nullptr;  // ✅ OK
int arr[5];        // always allocated

✅ Summary Table

| Feature             | Array                   | Pointer                      |
| ------------------- | ----------------------- | ---------------------------- |
| Type                | Fixed-size memory block | Stores address of a variable |
| Memory              | Compile-time allocation | Can be dynamic or static     |
| Size (sizeof)       | Total size of elements  | Size of address only         |
| Modifiable?         | ❌ Can't reassign        | ✅ Can be reassigned          |
| Supports arithmetic | ❌ No                    | ✅ Yes                        |
| Can be null?        | ❌ No                    | ✅ Yes                        |
| Passed to function  | Decays to pointer       | Passed as-is                 |
