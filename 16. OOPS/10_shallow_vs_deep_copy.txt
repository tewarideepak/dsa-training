ğŸ§  Shallow Copy vs Deep Copy in C++ â€“ OOP Notes

When copying objects in C++, especially those that use dynamic memory, it's important to understand the difference between shallow copy and deep copy.
ğŸ” 1. Shallow Copy
âœ… Definition:

A shallow copy copies the values of member variables as-is. For pointers, this means copying the address, not the actual memory content.

ğŸ“Œ Key Points:
| Feature          | Shallow Copy                                           |
| ---------------- | ------------------------------------------------------ |
| Pointer members  | Copies the pointer address only                        |
| Memory Ownership | Both objects share the **same memory**                 |
| Side Effect      | Changes in one object affect the other                 |
| Risk             | Double deletion â†’ âŒ program crash                      |
| Default in C++   | âœ… Yes (default copy constructor & assignment operator) |


ğŸ§ª Example of Shallow Copy:

class Sample {
public:
    int* data;
    Sample(int val) {
        data = new int(val);
    }

    ~Sample() {
        delete data;
    }

    void show() {
        cout << "Value: " << *data << endl;
    }
};

int main() {
    Sample s1(10);
    Sample s2 = s1;   // shallow copy â€” both point to same memory!
    *s2.data = 20;

    s1.show(); // Output: 20
    s2.show(); // Output: 20
    // Destructor called twice on same memory => crash
}

ğŸ” 2. Deep Copy
âœ… Definition:

A deep copy creates a completely independent copy of all member variables, including allocating new memory and copying the actual content.

ğŸ“Œ Key Points:

| Feature          | Deep Copy                                    |
| ---------------- | -------------------------------------------- |
| Pointer members  | New memory is allocated                      |
| Memory Ownership | Each object has its **own copy**             |
| Side Effect      | Changes in one object donâ€™t affect the other |
| Risk             | âŒ No risk of double deletion                 |
| Default in C++   | âŒ No, you must define manually               |


ğŸ§ª Example of Deep Copy:

class Sample {
public:
    int* data;
    Sample(int val) {
        data = new int(val);
    }

    // Deep copy constructor
    Sample(const Sample& s) {
        data = new int(*s.data);
    }

    ~Sample() {
        delete data;
    }

    void show() {
        cout << "Value: " << *data << endl;
    }
};

int main() {
    Sample s1(10);
    Sample s2 = s1;   // deep copy â€” separate memory

    *s2.data = 20;

    s1.show(); // Output: 10
    s2.show(); // Output: 20
}

âš–ï¸ Comparison Table

| Feature               | Shallow Copy                           | Deep Copy                              |
| --------------------- | -------------------------------------- | -------------------------------------- |
| Copies pointer values | âœ… Yes                                  | âŒ No, copies pointed-to values instead |
| Independent memory    | âŒ No                                   | âœ… Yes                                  |
| Memory efficiency     | âœ… More efficient (less memory)         | âŒ More memory used                     |
| Safety                | âŒ Risk of double free/dangling pointer | âœ… Safe                                 |
| Used by default       | âœ… Yes (compiler-generated)             | âŒ No (manual implementation needed)    |


ğŸ“Œ Summary

    ğŸ”„ Shallow Copy: Copies addresses â†’ shared memory â†’ risky.

    ğŸ’¡ Deep Copy: Allocates new memory â†’ fully independent â†’ safe.

    ğŸš« Always use deep copy when your class allocates dynamic memory (e.g. new, malloc).